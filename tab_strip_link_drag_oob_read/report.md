# Summary

When vertical tabs are turned on and a link is dragged over the tab strip, an OOB read will occur in the browser process if the window is closed during the drag.

# Description

From some investigation, the issue here appears to have the same root cause as Chromium issue 1209616:

https://bugs.chromium.org/p/chromium/issues/detail?id=1209616

That is, when a window is closed, there's a brief period where the window still exists, but contains no tabs. If a link is being dragged over the tab strip at that time, an OOB read can occur when retrieving the tab at the drop index.

In the linked issue, the problem was fixed by updating TabStrip::GetDropBounds to check whether the tab strip is empty. It's likely that a similar update needs to be made to EdgeTabStrip::GetDropBounds.

Note that the above applies when vertical tabs are turned on. When vertical tabs are turned off, EdgeTabStrip::GetDropBounds calls TabStrip::GetDropBounds and returns early. However, the browser will still crash, but in a different way.

The reason it still crashes is that TabStrip::GetDropBounds is supposed to return the direction for the drop arrow. However, if there are no tabs, TabStrip::GetDropBounds will return early. That then means that the direction will be uninitialized.

However, the although the value isn't initialized by the code, it appears that clang will automatically initialize it to a fixed value. As can be seen from the reference below, clang will automatically initialize integers and pointers with a repeating pattern of 0xAAâ€¦:

https://github.com/llvm/llvm-project/blob/c2e08aba1afd5a69dbe74b03ce6f463d45102222/clang/lib/CodeGen/PatternInit.cpp#L17

That means the direction will be automatically initialized to 0xAAAAAAAA.

TabStrip::DropArrow::SetDirection will then retrieve the necessary icon to show during the drag, based on the specified direction. However, if the direction isn't valid, the VectorIcon pointer won't be initialized by the code. That then causes clang to automatically initialize it, to the value 0xAAAAAAAAAAAAAAAA. That will then get passed to gfx::GetDefaultSizeOfVectorIcon, which will cause a crash when that function attempts to dereference the pointer.

As the comment in the above link indicates, 0xAAAAAAAAAAAAAAAA is a guaranteed unmappable pointer, so the crash here shouldn't be exploitable. However, it does still mean that certain values aren't being initialized correctly when a drag message is processed at the point at which a window has no tabs but still hasn't fully closed.

## Steps to Reproduce

1. Turn on vertical tabs.
2. Install the attached extension.
3. Once installed, the extension will create a window with a single tab. Drag a link (e.g. a bookmark, or the URL shown in the omnibox) over the tab strip in that window. Ensure the drop arrow shown in the tab strip appears in the middle of the tab or to the bottom (i.e. dragging the item anywhere within the tab strip will work, except towards the very top edge).
4. Five seconds after opening the window, the extension will close it. Providing the item being dragged is still over the tab strip, this should result in an out-of-bounds read in the browser process.

   Note that, as with the original Chromium issue, the effect here is somewhat dependent on timing, so you may have to try a few times for it to work.